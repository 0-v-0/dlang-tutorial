# 变量和数据类型

## 数据类型

D语言提供了一些基本数据类型，用于存储不同种类的数据。

### 基本数据类型

基本数据类型分为void和标量类型，void只能用于函数返回类型、类型比较和类型转换，不能用于声明变量。

标量类型是指只能存储单个值的数据类型。D语言提供了以下标量类型：

- 布尔类型：`bool`，默认值为`false`
- 整数类型：`byte`、`ubyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`，默认值为0
- 浮点数类型：`float`、`double`、`real`，默认值为NaN
- 字符类型：`char`、`wchar`、`dchar`，默认值分别为'\xFF'、'\uFFFF'、'\U0000FFFF'

### 派生数据类型

派生数据类型是从基本数据类型派生出来的，可以添加额外的特性或限制。

D语言提供了以下派生数据类型：

- 指针类型：指针是存储内存地址的变量，可以用于直接访问内存中的数据
- 静态数组：用于存储一组相同类型的值的连续内存块
- 动态数组：由长度和指针组成的值类型，有一个别名叫切片
- 关联数组：基于哈希表实现的一种引用类型
- 函数类型：函数指针
- 委托类型：由函数指针和一个上下文指针组成的值类型

这些派生数据类型可以根据需要来定义和使用。

### 用户定义的类型

用户定义的类型可以是一个或多个基本数据类型和派生数据类型的组合，有以下几类：

- 枚举：用于定义一组命名的常量值。
- 结构体：用于存储多个不同类型的值的集合。
- 联合体：用于存储多个不同类型的值的共享内存空间。
- 类：用于表示对象。
- 接口

以上除枚举外统称复合类型。

## 字面量
字面量是指直接在代码中表示特定值的标记。D语言中的字面量有以下几类：
- 布尔字面量：`true`和`false`
- 数值字面量：包括整数字面量、浮点数字面量
- 字符字面量：有`char`、`wchar`、`dchar`三种类型
- 数组字面量：包括字符串字面量等
- 函数字面量：包括函数和委托两种类型的字面量

`null`是一种特殊的字面量，可隐式转换为以下类型：
- 指针：表示空指针，这里的指针包括类、函数指针和委托
- 数组：表示空数组

下面是一些示例，展示了不同类型的字面量：

```d
int x = 10;        // 整数字面量
float y = 3.14f;   // 浮点数字面量
char c = 'A';      // 字符字面量
string a = [];     // 数组字面量
string s = "foo";  // 数组字面量
bool b = true;     // 布尔字面量
```

## 全局变量

全局变量是在函数外部定义的变量，可以在整个程序中访问（在其定义的位置前也能访问）。非共享的可变全局变量的存储位置在TLS中。

不可变全局变量由const或immutable修饰，只能在声明时或共享模块构造函数中初始化。

## typeof

`typeof`是一个运算符，可以用来获取表达式的类型。它可以用于编译时的类型检查。

下面是一个使用`typeof`运算符的示例：

```d
int x = 5;
typeof(x) y = 10;
```

`typeof`中的表达式不会被执行
```d
int i = 1;
typeof(++i) j; // j为int类型
writeln(i);  // 1
```

`typeof(return)`在函数中可代替函数的返回类型

如果表达式是一个属性函数，`typeof`的结果为该函数的返回类型
```d
struct S
{
    @property int foo() { return 1; }
}
typeof(S.foo) n; // n为int类型
```

如果表达式是一个模板，`typeof`的结果为void
```d
template T {}
static assert(is(typeof(T) == void));
```

**最佳实践：** typeof用于通用简化模板代码

## 值类型和引用类型

D语言中的数据类型可以分为值类型和引用类型。

值类型是指直接存储数据值的类型，变量存储的是实际的数据。当将一个值类型的变量赋值给另一个变量时，会创建一个新的副本。

引用类型是指存储数据地址的类型，变量存储的是数据的地址。当将一个引用类型的变量赋值给另一个变量时，两个变量将引用同一个数据。

下面是一个示例，演示了值类型和引用类型的区别：

```d
int a = 10;
int b = a;    // 创建一个a的副本

int[] array1 = [1, 2, 3];
int[] array2 = array1;  // array2引用array1

b = 20;            // a不受影响
array2[0] = 10;    // array1也会被修改

writeln(a); // 10
writeln(array1[0]); // 10
```